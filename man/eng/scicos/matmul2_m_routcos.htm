<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>matmul2_m_routcos</TITLE>
<META NAME="description" CONTENT="matmul2_m_routcos">
<META NAME="keywords" CONTENT="matmul2_m_routcos">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="matmul2_m_routcos.css">

</HEAD>

<BODY bgcolor="#FFFFFF">

<P>
<DIV ALIGN="CENTER">
Computational routine
<BR><A NAME="tex2html1"
  HREF="./matmul2_m_routcos.htm">eng</A>

</DIV>
<H2><A NAME="SECTION00010000000000000000"></A><A NAME="matmul2_m_routcos"></A>
<BR>
matmul2_m
</H2>

<H3><font color="blue"><A NAME="SECTION00011000000000000000">
File content</A>
</font></H3>
<BR>
<PRE  CLASS="verbatim">#include &lt;math.h&gt;
#include "scicos_block4.h"
#define matmul2(y1,u1,u2,mu,nu)  {for (i=0;i&lt;mu*nu;i++) y1[i]=u1[i]*u2[i];}

void matmul2_m(scicos_block *block,int flag)
{
 if (flag==1){
  int nu,mu,i,ut;
  ut=GetInType(block,1);
  mu=GetOutPortRows(block,1);
  nu=GetOutPortCols(block,1);
  switch (ut)
  {
      case SCSREAL_N :{
           double *u1,*u2,*y1;
           u1=GetRealInPortPtrs(block,1);
           u2=GetRealInPortPtrs(block,2);
           y1=GetRealOutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSINT32_N :{
           SCSINT32_COP *u1,*u2,*y1;
           u1=Getint32InPortPtrs(block,1);
           u2=Getint32InPortPtrs(block,2);
           y1=Getint32OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSINT16_N :{
           SCSINT16_COP *u1,*u2,*y1;
           u1=Getint16InPortPtrs(block,1);
           u2=Getint16InPortPtrs(block,2);
           y1=Getint16OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSINT8_N :{
           char *u1,*u2,*y1;
           u1=Getint8InPortPtrs(block,1);
           u2=Getint8InPortPtrs(block,2);
           y1=Getint8OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSUINT32_N :{
           SCSUINT32_COP *u1,*u2,*y1;
           u1=Getuint32InPortPtrs(block,1);
           u2=Getuint32InPortPtrs(block,2);
           y1=Getuint32OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSUINT16_N :{
           SCSUINT16_COP *u1,*u2,*y1;
           u1=Getuint16InPortPtrs(block,1);
           u2=Getuint16InPortPtrs(block,2);
           y1=Getuint16OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSUINT8_N :{
           SCSUINT8_COP *u1,*u2,*y1;
           u1=Getuint8InPortPtrs(block,1);
           u2=Getuint8InPortPtrs(block,2);
           y1=Getuint8OutPortPtrs(block,1);
           matmul2(y1,u1,u2,mu,nu);
           break;}

      case SCSCOMPLEX_N :{
           double *u1r,*u2r,*y1r;
           double *u1i,*u2i,*y1i;
           u1r=GetRealInPortPtrs(block,1);
           u2r=GetRealInPortPtrs(block,2);
           y1r=GetRealOutPortPtrs(block,1);
           u1i=GetImagInPortPtrs(block,1);
           u2i=GetImagInPortPtrs(block,2);
           y1i=GetImagOutPortPtrs(block,1);
           for (i=0;i&lt;mu*nu;i++) 
	     {y1r[i]=(u1r[i]*u2r[i])-(u1i[i]*u2i[i]);
	       y1i[i]=(u1r[i]*u2i[i])+(u1i[i]*u2r[i]);}
	   break;}

      default :{
          set_block_error(-4); 
	  return;} 
   } 
  }

}
</PRE>

<BR>




</BODY>
</HTML>
