<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>insertionassignation</title>
</head>
<body bgcolor="#FFFFFF">
<center>Scilab Function</center>
<div align="right">Last update : 29/02/2016</div>
<p><b>insertion</b> -   partial variable assignation
  or   modification</p>
<p><b>assignation</b> -  partial variable assignation</p>
<h3><font color="blue">Calling Sequence</font></h3>
<dl>
<dd><tt>x(i,j)=a</tt></dd>
<dd><tt>x(i)=a</tt></dd>
<dd><tt>l(i)=a</tt></dd>
<dd><tt>l(k1)...(kn)(i)=a or l(list(k1,...,kn,i))=a</tt></dd>
<dd><tt>l(k1)...(kn)(i,j)=a   or l(list(k1,...,kn,list(i,j))=a</tt></dd>
</dl>
<h3><font color="blue">Parameters</font></h3>
<ul>
<li>
<tt><b>x</b></tt>: matrix  of any  kind (constant, sparse, polynomial,...)</li>
<li>
<tt><b>l</b></tt>: list</li>
<li>
<tt><b>i,j</b></tt>: indices</li>
<li>
<tt><b>k1,...kn</b></tt>: indices  with integer value</li>
<li>
<tt><b>a</b></tt>: new entry value</li>
</ul>
<h3><font color="blue">Description</font></h3>
<dl>
<dd>
<b>MATRIX CASE</b>if <tt><b>x</b></tt> is a matrix the indices <tt><b>i</b></tt> and <tt><b>j</b></tt>, may be:<dl>
<dd>
<b>Real scalars or vectors or matrices</b>In this case the values given as indices should be positive and
       it is only their integer part which taken into account.<dl>
<dd>
<b></b><p>if <tt><b>a</b></tt> is a matrix with
            dimensions
            <tt><b>(size(i,'*'),size(j,'*'))</b></tt>,
            <tt><b>x(i,j)=a</b></tt> returns a new <tt><b>x</b></tt> matrix
            such as <tt><b>x(int(i(l)),int(j(k)))=a(l,k) </b></tt> for
            <tt><b>l</b></tt> from 1 to
            <tt><b>size(i,'*')</b></tt> and <tt><b>k</b></tt> from
            1 to <tt><b>size(j,'*')</b></tt>, other initial
            entries of <tt><b>x</b></tt> are unchanged. </p>
</dd>
<dd>
<b></b><p> if <tt><b>a</b></tt> is a scalar
           <tt><b>x(i,j)=a</b></tt> returns a new <tt><b>x</b></tt> matrix
           such as <tt><b>x(int(i(l)),int(j(k)))=a</b></tt> for
           <tt><b>l</b></tt> from 1 to <tt><b>size(i,'*')</b></tt>
           and <tt><b>k</b></tt> from 1 to
           <tt><b>size(j,'*')</b></tt>, other initial entries
           of <tt><b>x</b></tt> are unchanged. </p>
</dd>
<dd>
<b></b><p> If <tt><b>i</b></tt> or <tt><b>j</b></tt>
           maximum value exceed corresponding <tt><b>x</b></tt> matrix
           dimension, array <tt><b>x</b></tt> is previously extended to the
           required dimensions with zeros entries for standard
           matrices, 0 length character string for string matrices and
           false values for boolean matrices.
         </p>
</dd>
<dd>
<b></b><p><tt><b>x(i,j)=[]</b></tt> kills rows
           specified by <tt><b>i</b></tt> if <tt><b>j</b></tt> matches all
           columns of <tt><b>x</b></tt> or kills columns specified by
           <tt><b>j</b></tt> if <tt><b>i</b></tt> matches all rows of
           <tt><b>x</b></tt>. In other cases <tt><b>x(i,j)=[]</b></tt>
           produce an error. </p>
</dd>
<dd>
<b></b><p><tt><b>x(i)=a</b></tt> with <tt><b>a</b></tt> a
           vector returns a new <tt><b>x</b></tt> matrix such as
           <tt><b>x(int(i(l)))=a(l)</b></tt> for <tt><b>l</b></tt> from 1 to
           <tt><b>size(i,'*')</b></tt> , other initial entries
           of <tt><b>x</b></tt> are unchanged. </p>
</dd>
<dd>
<b></b><p><tt><b>x(i)=a</b></tt> with <tt><b>a</b></tt> a
           scalar returns a new <tt><b>x</b></tt> matrix such as
           <tt><b>x(int(i(l)))=a</b></tt> for <tt><b>l</b></tt> from 1 to
           <tt><b>size(i,'*')</b></tt> , other initial entries
           of <tt><b>x</b></tt> are unchanged. </p>
<p>
          If <tt><b>i</b></tt> maximum value exceed
          <tt><b>size(x,1)</b></tt>, <tt><b>x</b></tt> is previously
          extended to the required dimension with zeros entries for
          standard matrices, 0 length character string for string
          matrices and false values for boolean matrices.
          </p>
<dl>
<dd>
<b>if</b><tt><b>x</b></tt> is a 1x1<p>
              matrix <tt><b>a</b></tt> may be a row (respectively a
              column) vector with dimension
              <tt><b>size(i,'*')</b></tt>. Resulting
              <tt><b>x</b></tt> matrix is a row (respectively a column)
              vector
            </p>
</dd>
<dd>
<b>if</b><tt><b>x</b></tt> is a row<p>
               vector <tt><b>a</b></tt> must be a row vector with
               dimension <tt><b>size(i,'*')</b></tt></p>
</dd>
<dd>
<b>if</b><tt><b>x</b></tt> is a column<p>
               vector <tt><b>a</b></tt> must be a column vector with
               dimension <tt><b>size(i,'*')</b></tt></p>
</dd>
<dd>
<b>if</b><tt><b>x</b></tt> is a general<p>
               matrix <tt><b>a</b></tt> must be a row or column vector
               with dimension <tt><b>size(i,'*')</b></tt> and
               <tt><b>i</b></tt> maximum value cannot exceed
               <tt><b>size(x,'*')</b></tt>,
            </p>
</dd>
</dl>
</dd>
<dd>
<b></b><p><tt><b>x(i)=[]</b></tt> kills entries
            specified by <tt><b>i</b></tt>.
         </p>
</dd>
</dl>
</dd>
<dd>
<b>The : symbol</b>the <tt><b>:</b></tt> symbol stands for "all elements".<dl>
<dd>
<b></b><p><tt><b>x(i,:)=a</b></tt> is interpreted as
             <tt><b>x(i,1:size(x,2))=a</b></tt></p>
</dd>
<dd>
<b></b><p><tt><b>x(:,j)=a</b></tt> is interpreted as
            <tt><b>x(1:size(x,1),j)=a</b></tt></p>
</dd>
<dd>
<b></b><p><tt><b>x(:)=a</b></tt> returns in
            <tt><b>x</b></tt> the <tt><b>a</b></tt> matrix reshaped
            according to x
            dimensions. <tt><b>size(x,'*')</b></tt> must be
            equal to <tt><b>size(a,'*')</b></tt></p>
</dd>
</dl>
</dd>
<dd>
<b>Vectors of boolean</b>If an index (<tt><b>i</b></tt> or <tt><b>j</b></tt> )is a vector
          of booleans it is interpreted as <tt><b>find(i)</b></tt> or
          respectively <tt><b>find(j)</b></tt>
</dd>
<dd>
<b>Polynomials</b>If an index (<tt><b>i</b></tt> or <tt><b>j</b></tt> )is a vector of
         polynomials or implicit polynomial vector it is interpreted
         as <tt><b>horner(i,m)</b></tt> or respectively
         <tt><b>horner(j,n)</b></tt> where <tt><b>m</b></tt> and
         <tt><b>n</b></tt> are associated <tt><b>x</b></tt> dimensions.
         Even if this feature works for all polynomials, it is
         recommended to use polynomials in <tt><b>$</b></tt> for
         readability.</dd>
</dl>
</dd>
<dd>
<b>LIST OR TLIST CASE</b><dl>
<dd>
<b></b><p>If they are present
        the <tt><b>ki</b></tt> give the path to a sub-list entry of
        <tt><b>l</b></tt> data structure. They allow a recursive insertion
        without intermediate copies.  The <tt><b>l(k1)...(kn)(i)=a</b></tt>
        and <tt><b>l(list(k1,...,kn,i)=a)</b></tt> instructions are
        interpreted as:</p>
<p><tt><b>lk1 = l(k1)</b></tt><tt><b> ..  = ..  </b></tt></p>
<p><tt><b>lkn = lkn-1(kn)</b></tt><tt><b> lkn(i) = a</b></tt></p>
<p><tt><b>lkn-1(kn) = lkn</b></tt><tt><b> ..  = ..  </b></tt><tt><b>l(k1) = lk1</b></tt></p>
<p>
        And the <tt><b>l(k1)...(kn)(i,j)=a</b></tt> and  <tt><b>l(list(k1,...,kn,list(i,j))=a</b></tt> 
        instructions are interpreted as:</p>
<p><tt><b>lk1 = l(k1)</b></tt><tt><b> ..  = ..  </b></tt></p>
<p><tt><b>lkn = lkn-1(kn)</b></tt><tt><b>lkn(i,j) = a</b></tt></p>
<p><tt><b>lkn-1(kn) = lkn</b></tt><tt><b> ..  = ..  </b></tt><tt><b>l(k1)= lk1</b></tt></p>
</dd>
<dd>
<b></b><p><tt><b>i</b></tt> may be :</p>
<dl>
<dd>
<b></b><p> a real non negative scalar.
           <tt><b>l(0)=a</b></tt> adds an entry on the "left"
           of the list <tt><b>l(i)=a</b></tt> sets the <tt><b>i</b></tt>
           entry of the list <tt><b>l</b></tt> to <tt><b>a</b></tt>. if
           <tt><b>i&gt;size(l)</b></tt>, <tt><b>l</b></tt> is previously
           extended with zero length entries (undefined).
           <tt><b>l(i)=null()</b></tt> suppress the <tt><b>i</b></tt>th list
           entry.</p>
</dd>
<dd>
<b></b><p> a polynomial.  If <tt><b>i</b></tt> is a
            polynomial it is interpreted as <tt><b>horner(i,m)</b></tt>
            where <tt><b>m=size(l)</b></tt>.  Even if this feature works
            for all polynomials, it is recommended to use polynomials
            in <tt><b>$</b></tt> for readability.</p>
</dd>
</dl>
</dd>
<dd>
<b></b><p><tt><b>k1,..kn</b></tt> may be :</p>
<dl>
<dd>
<b></b><p> 
            real positive scalar.</p>
</dd>
<dd>
<b></b><p> a polynomial,interpreted as
            <tt><b>horner(ki,m)</b></tt> where <tt><b>m</b></tt> is the
            corresponding sub-list size.</p>
</dd>
<dd>
<b></b><p> a character string associated with a
            sub-list entry name.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<h3><font color="blue">Remarks</font></h3>
<dl><p>
    For soft coded matrix types such as rational functions and state space linear systems, <tt><b>x(i)</b></tt> syntax may not be used for vector entry insertion due to confusion with list entry insertion. <tt><b>x(1,j)</b></tt> or <tt><b>x(i,1)</b></tt> syntax must be used.</p></dl>
<h3><font color="blue">Examples</font></h3>
<pre>

// MATRIX CASE
a=[1 2 3;4 5 6]
a(1,2)=10
a([1 1],2)=[-1;-2]
a(:,1)=[8;5]
a(1,3:-1:1)=[77 44 99]
a(1)=%s
a(6)=%s+1
a(:)=1:6
a([%t %f],1)=33
a(1:2,$-1)=[2;4]
a($:-1:1,1)=[8;7]
a($)=123
//
x='test'
x([4 5])=['4','5']
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)=0
b(1,$)=b(1,$)+1
b(2)=[1 2] // the numerator
// LIST OR TLIST CASE
l=list(1,'qwerw',%s)
l(1)='Changed'
l(0)='Added'
l(6)=['one more';'added']
//
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2).a=33
dts(2)('b')(1,2)=-100
 
  </pre>
<h3><font color="blue">See Also</font></h3>
<p><a href="../../../../../../home/jpc/Download/scicoslab/man/eng/programming/find.htm"><tt><b>find</b></tt></a>,&nbsp;&nbsp;<a href="../../../../../../home/jpc/Download/scicoslab/man/eng/polynomials/horner.htm"><tt><b>horner</b></tt></a>,&nbsp;&nbsp;<a href="../../../../../../home/jpc/Download/scicoslab/man/eng/programming/parents.htm"><tt><b>parents</b></tt></a>,&nbsp;&nbsp;<a href="../../../../../../home/jpc/Download/scicoslab/man/eng/programming/extraction.htm"><tt><b>extraction</b></tt></a>,&nbsp;&nbsp;</p>
</body>
</html>
